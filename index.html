<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kotlin Coroutines - Detailed Animation Visualizer</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.svg">
    <meta name="theme-color" content="#667eea">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f0f2f5;
            min-height: 100vh;
            padding: 20px;
        }

        .main-container {
            max-width: 1600px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 25px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        h1 {
            color: #1a1a1a;
            font-size: 2.2em;
            margin-bottom: 8px;
        }

        .subtitle {
            color: #666;
            font-size: 1.1em;
        }

        .controls-panel {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn:hover {
            transform: translateY(-1px);
        }

        .btn-primary {
            background: #0066cc;
            color: white;
        }

        .btn-primary:hover {
            background: #0052a3;
        }

        .btn-secondary {
            background: #e0e0e0;
            color: #333;
        }

        .btn-secondary:hover {
            background: #d0d0d0;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .content-wrapper {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            margin-bottom: 30px;
        }

        .coroutine-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
        }

        .coroutine-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            border: 1px solid #e0e0e0;
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #f0f0f0;
        }

        .card-title {
            font-size: 1.3em;
            font-weight: 600;
            color: #1a1a1a;
        }

        .status-badge {
            padding: 4px 12px;
            border-radius: 16px;
            font-size: 0.85em;
            font-weight: 500;
        }

        .status-idle {
            background: #f0f0f0;
            color: #666;
        }

        .status-running {
            background: #d4f4dd;
            color: #1a7431;
            animation: pulse 1.5s infinite;
        }

        .status-suspended {
            background: #fff3cd;
            color: #856404;
        }

        .status-completed {
            background: #cce5ff;
            color: #004085;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .description {
            color: #666;
            font-size: 0.95em;
            line-height: 1.5;
            margin-bottom: 15px;
        }

        .visualization-area {
            min-height: 300px;
            background: #f8f9fa;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            margin-bottom: 15px;
            border: 1px solid #e0e0e0;
        }

        .visualization-header {
            background: #fff;
            padding: 10px 15px;
            border-bottom: 1px solid #e0e0e0;
            font-size: 0.9em;
            color: #666;
        }

        .visualization-content {
            padding: 20px;
            min-height: 250px;
            position: relative;
        }

        .timeline {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            height: 4px;
            background: #e0e0e0;
            border-radius: 2px;
        }

        .progress-bar {
            height: 100%;
            background: #0066cc;
            border-radius: 2px;
            width: 0%;
            transition: width 0.3s ease;
        }

        .log-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            border: 1px solid #e0e0e0;
            max-height: 800px;
            overflow-y: auto;
            position: sticky;
            top: 20px;
        }

        .log-panel h3 {
            margin-bottom: 15px;
            color: #1a1a1a;
            font-size: 1.1em;
        }

        .log-entry {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 0.85em;
            padding: 8px 12px;
            margin-bottom: 4px;
            border-radius: 4px;
            background: #f8f9fa;
            border-left: 3px solid #e0e0e0;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .log-time {
            color: #666;
            margin-right: 8px;
        }

        .log-launch {
            border-left-color: #f093fb;
            background: #fdf6fd;
        }

        .log-async {
            border-left-color: #4facfe;
            background: #f0f8ff;
        }

        .log-cold-flow {
            border-left-color: #3498db;
            background: #e8f4fd;
        }

        .log-shared-flow {
            border-left-color: #2ecc71;
            background: #e8f8f0;
        }

        .log-state-flow {
            border-left-color: #f39c12;
            background: #fef5e7;
        }

        .log-channel {
            border-left-color: #e74c3c;
            background: #fdeaea;
        }

        .log-context {
            border-left-color: #9b59b6;
            background: #f4ecf7;
        }

        .log-blocking {
            border-left-color: #34495e;
            background: #ecf0f1;
        }

        .code-snippet {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 6px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 0.85em;
            overflow-x: auto;
            margin-bottom: 15px;
        }

        .code-comment {
            color: #718096;
        }

        .code-keyword {
            color: #f687b3;
        }

        .code-function {
            color: #9f7aea;
        }

        .code-string {
            color: #68d391;
        }

        /* Visualization Elements */
        .flow-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
        }

        .collector-row {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 2px dashed #e0e0e0;
            position: relative;
        }

        .collector-row.active {
            border-color: #0066cc;
            background: #f0f8ff;
        }

        .collector-label {
            min-width: 100px;
            font-weight: 500;
            color: #333;
        }

        .emission-track {
            flex: 1;
            height: 40px;
            background: #f0f0f0;
            border-radius: 20px;
            position: relative;
            overflow: hidden;
        }

        .emission {
            position: absolute;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.9em;
            top: 2px;
            transition: transform 0.5s ease;
        }

        .emission-cold {
            background: #3498db;
        }

        .emission-hot {
            background: #e74c3c;
        }

        .emission-shared {
            background: #2ecc71;
        }

        .emission-state {
            background: #f39c12;
        }

        .emission-channel {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }

        .thread-pool {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px 0;
        }

        .thread {
            padding: 20px;
            background: #f0f0f0;
            border-radius: 8px;
            text-align: center;
            font-weight: 500;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .thread.active {
            background: #0066cc;
            color: white;
            border-color: #0052a3;
            transform: scale(1.05);
        }

        .coroutine-visual {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 6px;
            display: inline-block;
            margin: 5px;
            font-size: 0.9em;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .explanation-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 12px 16px;
            margin: 15px 0;
            border-radius: 4px;
            font-size: 0.9em;
            color: #1565c0;
        }

        .buffer-visualization {
            display: flex;
            gap: 8px;
            margin: 10px 0;
            align-items: center;
        }

        .buffer-slot {
            width: 40px;
            height: 40px;
            border: 2px solid #ddd;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            background: white;
            transition: all 0.3s ease;
        }

        .buffer-slot.filled {
            background: #2ecc71;
            color: white;
            border-color: #27ae60;
        }

        .state-display {
            font-size: 2em;
            font-weight: bold;
            color: #f39c12;
            text-align: center;
            padding: 20px;
            background: #fef5e7;
            border-radius: 8px;
            margin: 10px 0;
        }

        .channel-queue {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 20px 0;
        }

        .queue-item {
            padding: 8px 16px;
            background: #fa709a;
            color: white;
            border-radius: 6px;
            font-weight: 500;
            animation: queueIn 0.3s ease;
        }

        @keyframes queueIn {
            from { transform: scale(0); }
            to { transform: scale(1); }
        }

        .clear-log-btn {
            float: right;
            font-size: 0.85em;
            padding: 5px 10px;
        }

        .highlight {
            background: #fff3cd;
            padding: 2px 4px;
            border-radius: 3px;
        }

        /* Support/Donation Button Styles */
        .donation-floating {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 248, 240, 0.95);
            border-radius: 15px;
            padding: 12px 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            border: 1px solid rgba(255, 224, 204, 0.8);
            z-index: 1000;
            transition: all 0.3s ease;
            max-width: 200px;
            opacity: 0;
            animation: fadeInFloat 2s ease-in-out 3s forwards;
            backdrop-filter: blur(10px);
        }

        @keyframes fadeInFloat {
            0% {
                opacity: 0;
                transform: translateY(20px);
            }
            100% {
                opacity: 0.9;
                transform: translateY(0);
            }
        }

        .donation-floating:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(0,0,0,0.25);
            background: rgba(255, 248, 240, 1);
            opacity: 1;
            border: 1px solid rgba(255, 224, 204, 1);
        }

        .donation-floating .donation-text {
            font-size: 0.85em;
            color: #8d6e63;
            margin-bottom: 8px;
            line-height: 1.3;
            text-align: center;
            font-weight: 500;
        }

        .donation-floating .kofi-button-container {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .donation-floating .kofi-button-container a {
            transition: all 0.3s ease;
            border-radius: 6px;
            display: inline-block;
        }

        .donation-floating .kofi-button-container a:hover {
            transform: scale(1.05);
        }

        .donation-floating .kofi-button-container img {
            height: 28px !important;
            border-radius: 4px;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .donation-floating {
                bottom: 15px;
                right: 15px;
                padding: 8px 12px;
                max-width: 160px;
                border-radius: 12px;
            }

            .donation-floating .donation-text {
                font-size: 0.75em;
                margin-bottom: 6px;
            }

            .donation-floating .kofi-button-container img {
                height: 24px !important;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="header">
            <h1>Kotlin Coroutines - Detailed Animation Visualizer</h1>
            <p class="subtitle">Watch step-by-step execution with detailed logging</p>
        </div>

        <div class="controls-panel">
            <button class="btn btn-primary" onclick="startAllAnimations()">
                ▶️ Start All Animations
            </button>
            <button class="btn btn-secondary" onclick="resetAllAnimations()">
                🔄 Reset All
            </button>
            <button class="btn btn-danger clear-log-btn" onclick="clearLogs()">
                🗑️ Clear Logs
            </button>
        </div>

        <div class="content-wrapper">
            <div class="coroutine-grid">
                <!-- Cold Flow -->
                <div class="coroutine-card">
                    <div class="card-header">
                        <h3 class="card-title">Cold Flow</h3>
                        <span class="status-badge status-idle" id="cold-flow-status">Idle</span>
                    </div>
                    <p class="description">
                        Each collector triggers a <strong>new, independent</strong> flow execution from the beginning.
                        Think of it like a YouTube video - each viewer starts from the beginning.
                    </p>
                    <div class="explanation-box" style="background: #e8f4fd; border-color: #3498db;">
                        <strong>❄️ COLD FLOW = Fresh Execution Per Collector</strong>
                        <div style="margin: 8px 0; padding: 8px; background: #f0f8ff; border-radius: 4px; font-size: 0.9em;">
                            <strong>🎯 When to use:</strong> When each collector should trigger its own fresh execution
                        </div>
                        <ul style="margin: 5px 0 0 20px; font-size: 0.9em;">
                            <li>Database queries - each UI component gets fresh data</li>
                            <li>Network requests - each subscriber triggers its own API call</li>
                            <li>File reading operations - each collector reads from start</li>
                            <li>User-specific calculations - personalized for each observer</li>
                        </ul>
                    </div>
                    <div class="code-snippet">
                        <span class="code-keyword">val</span> coldFlow = <span class="code-function">flow</span> {
                            <span class="code-comment">// This block runs for EACH collector</span>
                            <span class="code-function">emit</span>(<span class="code-string">1</span>)
                            <span class="code-function">delay</span>(<span class="code-string">1000</span>)
                            <span class="code-function">emit</span>(<span class="code-string">2</span>)
                            <span class="code-function">delay</span>(<span class="code-string">1000</span>)
                            <span class="code-function">emit</span>(<span class="code-string">3</span>)
                        }
                        
                        <span class="code-comment">// Collector 1 starts</span>
                        coldFlow.<span class="code-function">collect</span> { <span class="code-function">println</span>(it) }
                        
                        <span class="code-comment">// Collector 2 starts (independent execution)</span>
                        coldFlow.<span class="code-function">collect</span> { <span class="code-function">println</span>(it) }
                    </div>
                    <div class="visualization-area">
                        <div class="visualization-header">Flow Execution Timeline</div>
                        <div class="visualization-content" id="cold-flow-viz">
                            <div class="flow-container" id="cold-flow-collectors">
                                <!-- Collectors will be added here -->
                            </div>
                        </div>
                    </div>
                    <button class="btn btn-primary" onclick="animateColdFlow()">
                        ▶️ Start Cold Flow
                    </button>
                </div>

                <!-- Hot Flow (SharedFlow) -->
                <div class="coroutine-card">
                    <div class="card-header">
                        <h3 class="card-title">SharedFlow (Hot)</h3>
                        <span class="status-badge status-idle" id="shared-flow-status">Idle</span>
                    </div>
                    <p class="description">
                        Broadcasts values to <strong>all active collectors</strong>. New collectors can get recent values from replay buffer.
                        Like a live TV broadcast - you join wherever it currently is.
                    </p>
                    <div class="explanation-box" style="background: #e8f8f0; border-color: #2ecc71;">
                        <strong>🔥 HOT FLOW = One Source, Many Receivers</strong>
                        <div style="margin: 8px 0; padding: 8px; background: #f0fff0; border-radius: 4px; font-size: 0.9em;">
                            <strong>🎯 When to use:</strong> When you want to broadcast events/updates to multiple listeners
                        </div>
                        <ul style="margin: 5px 0 0 20px; font-size: 0.9em;">
                            <li>Event bus - app-wide events (user login, logout, etc.)</li>
                            <li>Live data streams - stock prices, sensor readings</li>
                            <li>Chat messages - broadcast to all connected users</li>
                            <li>Progress updates - file upload/download progress to multiple UI components</li>
                        </ul>
                    </div>
                    <div class="code-snippet">
                        <span class="code-keyword">val</span> sharedFlow = <span class="code-function">MutableSharedFlow</span>&lt;Int&gt;(
                            replay = <span class="code-string">2</span> <span class="code-comment">// Keep last 2 values</span>
                        )
                        
                        <span class="code-comment">// Producer emits continuously</span>
                        <span class="code-keyword">launch</span> {
                            <span class="code-keyword">repeat</span>(<span class="code-string">5</span>) {
                                sharedFlow.<span class="code-function">emit</span>(it)
                                <span class="code-function">delay</span>(<span class="code-string">1000</span>)
                            }
                        }
                        
                        <span class="code-comment">// Collectors join at different times</span>
                        <span class="code-keyword">launch</span> { sharedFlow.<span class="code-function">collect</span> { } } <span class="code-comment">// Gets all</span>
                        <span class="code-function">delay</span>(<span class="code-string">2500</span>)
                        <span class="code-keyword">launch</span> { sharedFlow.<span class="code-function">collect</span> { } } <span class="code-comment">// Gets replay + new</span>
                    </div>
                    <div class="visualization-area">
                        <div class="visualization-header">Broadcasting Timeline</div>
                        <div class="visualization-content" id="shared-flow-viz">
                            <div class="explanation-box">
                                📡 SharedFlow broadcasts to all active subscribers
                            </div>
                            <div style="margin: 20px 0;">
                                <strong>Replay Buffer:</strong>
                                <div class="buffer-visualization" id="shared-buffer">
                                    <div class="buffer-slot">-</div>
                                    <div class="buffer-slot">-</div>
                                </div>
                            </div>
                            <div class="flow-container" id="shared-flow-collectors">
                                <!-- Collectors will be added here -->
                            </div>
                        </div>
                    </div>
                    <button class="btn btn-primary" onclick="animateSharedFlow()">
                        ▶️ Start SharedFlow
                    </button>
                </div>

                <!-- StateFlow -->
                <div class="coroutine-card">
                    <div class="card-header">
                        <h3 class="card-title">StateFlow</h3>
                        <span class="status-badge status-idle" id="state-flow-status">Idle</span>
                    </div>
                    <p class="description">
                        Always holds <strong>one current value</strong>. New collectors immediately get the current state.
                        Automatically skips consecutive duplicate values. Perfect for UI state.
                    </p>
                    <div class="explanation-box" style="background: #fef5e7; border-color: #f39c12;">
                        <strong>🔄 Real-World Use Case:</strong> Best for representing current state that multiple components need:
                        <ul style="margin: 5px 0 0 20px; font-size: 0.9em;">
                            <li>UI state - current screen, theme mode, user preferences</li>
                            <li>User authentication state - logged in/out status</li>
                            <li>App configuration - settings that components need to read</li>
                            <li>Selected items - current selection in lists or navigation</li>
                        </ul>
                    </div>
                    <div class="code-snippet">
                        <span class="code-keyword">val</span> stateFlow = <span class="code-function">MutableStateFlow</span>(<span class="code-string">0</span>)
                        
                        <span class="code-comment">// Update state</span>
                        stateFlow.value = <span class="code-string">1</span>
                        stateFlow.value = <span class="code-string">2</span>
                        stateFlow.value = <span class="code-string">2</span> <span class="code-comment">// Skipped! (duplicate)</span>
                        stateFlow.value = <span class="code-string">3</span>
                        
                        <span class="code-comment">// New collector gets current value (3) immediately</span>
                        stateFlow.<span class="code-function">collect</span> { state ->
                            <span class="code-function">println</span>(<span class="code-string">"State: $state"</span>)
                        }
                    </div>
                    <div class="visualization-area">
                        <div class="visualization-header">State Updates</div>
                        <div class="visualization-content" id="state-flow-viz">
                            <div class="state-display" id="current-state">
                                Current State: 0
                            </div>
                            <div class="explanation-box">
                                💡 StateFlow always has a value and skips duplicate consecutive emissions
                            </div>
                            <div id="state-updates-timeline" style="margin-top: 20px;">
                                <!-- State updates will be shown here -->
                            </div>
                        </div>
                    </div>
                    <button class="btn btn-primary" onclick="animateStateFlow()">
                        ▶️ Start StateFlow
                    </button>
                </div>

                <!-- Channel -->
                <div class="coroutine-card">
                    <div class="card-header">
                        <h3 class="card-title">Channel</h3>
                        <span class="status-badge status-idle" id="channel-status">Idle</span>
                    </div>
                    <p class="description">
                        Hot stream for <strong>coroutine communication</strong>. Each value is consumed by only one receiver.
                        Like a queue where items are removed when received.
                    </p>
                    <div class="explanation-box" style="background: #fdeaea; border-color: #e74c3c;">
                        <strong>📬 CHANNEL = Queue-like Communication</strong>
                        <div style="margin: 8px 0; padding: 8px; background: #fff5f5; border-radius: 4px; font-size: 0.9em;">
                            <strong>🔄 Channel Types:</strong><br>
                            • <strong>Rendezvous (capacity = 0):</strong> Direct handoff, sender waits for receiver<br>
                            • <strong>Buffered (capacity > 0):</strong> Queue with buffer space
                        </div>
                        <ul style="margin: 5px 0 0 20px; font-size: 0.9em;">
                            <li>Task queues - processing background jobs one at a time</li>
                            <li>Actor model - sending messages to actors for processing</li>
                            <li>Rate limiting - controlling flow of requests or events</li>
                            <li>Load balancing - distributing work among multiple workers</li>
                        </ul>
                    </div>
                    <div class="code-snippet">
                        <span class="code-comment">// Rendezvous Channel (default) - Direct handoff</span>
                        <span class="code-keyword">val</span> rendezvous = <span class="code-function">Channel</span>&lt;Int&gt;()
                        <span class="code-comment">// Sender waits until receiver is ready</span>
                        
                        <span class="code-comment">// Buffered Channel - Has queue space</span>
                        <span class="code-keyword">val</span> buffered = <span class="code-function">Channel</span>&lt;Int&gt;(capacity = <span class="code-string">3</span>)
                        <span class="code-comment">// Sender doesn't wait if buffer has space</span>
                        
                        <span class="code-comment">// Producer-Consumer pattern</span>
                        <span class="code-keyword">launch</span> { channel.<span class="code-function">send</span>(value) }
                        <span class="code-keyword">launch</span> { 
                            <span class="code-keyword">val</span> received = channel.<span class="code-function">receive</span>()
                        }
                    </div>
                    <div class="visualization-area">
                        <div class="visualization-header">Channel Types Demonstration</div>
                        <div class="visualization-content" id="channel-viz">
                            <div class="explanation-box">
                                📬 Watch the difference between Rendezvous and Buffered channels
                            </div>
                            
                            <!-- Channel Mode Selector -->
                            <div style="text-align: center; margin: 15px 0;">
                                <button class="btn btn-secondary" onclick="switchChannelMode('rendezvous')" id="rendezvous-btn">
                                    🤝 Rendezvous Channel
                                </button>
                                <button class="btn btn-secondary" onclick="switchChannelMode('buffered')" id="buffered-btn">
                                    📦 Buffered Channel
                                </button>
                            </div>
                            
                            <!-- Current Mode Display -->
                            <div id="channel-mode-display" style="text-align: center; margin: 10px 0; font-weight: bold; color: #666;">
                                Mode: Rendezvous (capacity = 0)
                            </div>
                            
                            <div style="display: flex; align-items: center; justify-content: space-between; margin: 20px 0;">
                                <div>
                                    <strong>Producer</strong>
                                    <div id="channel-producer" style="margin-top: 10px;">
                                        <!-- Producer visualization -->
                                    </div>
                                </div>
                                <div style="flex: 1; margin: 0 20px;">
                                    <strong>Channel:</strong>
                                    <div class="channel-queue" id="channel-queue">
                                        <!-- Queue items or rendezvous indicator -->
                                    </div>
                                    <div id="rendezvous-indicator" style="text-align: center; margin-top: 10px; font-size: 0.9em; color: #e74c3c;">
                                        <!-- Rendezvous status -->
                                    </div>
                                </div>
                                <div>
                                    <strong>Consumer</strong>
                                    <div id="channel-consumer" style="margin-top: 10px;">
                                        <!-- Consumer visualization -->
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <button class="btn btn-primary" onclick="animateChannel()">
                        ▶️ Start Channel
                    </button>
                </div>

                <!-- withContext -->
                <div class="coroutine-card">
                    <div class="card-header">
                        <h3 class="card-title">withContext</h3>
                        <span class="status-badge status-idle" id="context-status">Idle</span>
                    </div>
                    <p class="description">
                        Switches the coroutine to a different <strong>dispatcher/thread</strong> and returns result.
                        Essential for performing UI updates on Main thread or IO operations on IO thread.
                    </p>
                    <div class="explanation-box" style="background: #f4ecf7; border-color: #9b59b6;">
                        <strong>🔄 Real-World Use Case:</strong> Essential for thread management in real apps:
                        <ul style="margin: 5px 0 0 20px; font-size: 0.9em;">
                            <li>Network calls on IO thread, then update UI on Main thread</li>
                            <li>Heavy computations on Default thread, preserve UI responsiveness</li>
                            <li>File operations on IO, then process results on CPU threads</li>
                            <li>Database queries on IO, then update UI components safely</li>
                        </ul>
                    </div>
                    <div class="code-snippet">
                        <span class="code-keyword">suspend fun</span> <span class="code-function">loadData</span>() = <span class="code-keyword">coroutineScope</span> {
                            <span class="code-comment">// Start on Main thread</span>
                            <span class="code-function">println</span>(<span class="code-string">"Starting on: ${Thread.currentThread()}"</span>)
                            
                            <span class="code-keyword">val</span> data = <span class="code-keyword">withContext</span>(Dispatchers.IO) {
                                <span class="code-comment">// Switch to IO thread</span>
                                <span class="code-function">readFromNetwork</span>()
                            }
                            
                            <span class="code-keyword">withContext</span>(Dispatchers.Main) {
                                <span class="code-comment">// Back to Main thread</span>
                                <span class="code-function">updateUI</span>(data)
                            }
                        }
                    </div>
                    <div class="visualization-area">
                        <div class="visualization-header">Thread Context Switching</div>
                        <div class="visualization-content" id="context-viz">
                            <div class="thread-pool">
                                <div class="thread" id="main-thread">
                                    <div>Main Thread</div>
                                    <small>UI Operations</small>
                                </div>
                                <div class="thread" id="io-thread">
                                    <div>IO Thread</div>
                                    <small>Network/File IO</small>
                                </div>
                                <div class="thread" id="default-thread">
                                    <div>Default Thread</div>
                                    <small>CPU Operations</small>
                                </div>
                            </div>
                            <div id="context-coroutine" style="margin-top: 20px; text-align: center;">
                                <!-- Coroutine visualization -->
                            </div>
                        </div>
                    </div>
                    <button class="btn btn-primary" onclick="animateContext()">
                        ▶️ Start Context Switch
                    </button>
                </div>

                <!-- launch -->
                <div class="coroutine-card">
                    <div class="card-header">
                        <h3 class="card-title">launch { }</h3>
                        <span class="status-badge status-idle" id="launch-status">Idle</span>
                    </div>
                    <p class="description">
                        Fire-and-forget coroutine. Starts a new coroutine and <strong>doesn't return a result</strong>.
                        Returns a Job that can be used to cancel the coroutine.
                    </p>
                    <div class="explanation-box" style="background: #fdf6fd; border-color: #f093fb;">
                        <strong>🚀 Real-World Use Case:</strong> Perfect for independent background tasks:
                        <ul style="margin: 5px 0 0 20px; font-size: 0.9em;">
                            <li>Logging events - fire-and-forget logging operations</li>
                            <li>Analytics tracking - send events without waiting for response</li>
                            <li>Cache warming - preload data in background</li>
                            <li>Background sync - periodic data synchronization</li>
                        </ul>
                    </div>
                    <div class="code-snippet">
                        <span class="code-keyword">val</span> job = <span class="code-keyword">launch</span> {
                            <span class="code-comment">// This runs asynchronously</span>
                            <span class="code-function">println</span>(<span class="code-string">"Coroutine started"</span>)
                            <span class="code-function">delay</span>(<span class="code-string">2000</span>)
                            <span class="code-function">println</span>(<span class="code-string">"Coroutine finished"</span>)
                        }
                        
                        <span class="code-comment">// Main code continues immediately</span>
                        <span class="code-function">println</span>(<span class="code-string">"Main continues"</span>)
                        
                        <span class="code-comment">// Can cancel if needed</span>
                        job.<span class="code-function">cancel</span>()
                    </div>
                    <div class="visualization-area">
                        <div class="visualization-header">Coroutine Execution</div>
                        <div class="visualization-content" id="launch-viz">
                            <div style="text-align: center; padding: 40px;">
                                <div id="launch-coroutine">
                                    <!-- Launch visualization -->
                                </div>
                            </div>
                            <div class="timeline">
                                <div class="progress-bar" id="launch-progress"></div>
                            </div>
                        </div>
                    </div>
                    <button class="btn btn-primary" onclick="animateLaunch()">
                        ▶️ Start Launch
                    </button>
                </div>

                <!-- async -->
                <div class="coroutine-card">
                    <div class="card-header">
                        <h3 class="card-title">async { }</h3>
                        <span class="status-badge status-idle" id="async-status">Idle</span>
                    </div>
                    <p class="description">
                        Creates a coroutine that <strong>returns a result</strong>. Returns Deferred&lt;T&gt; immediately.
                        Use await() to get the actual result when needed.
                    </p>
                    <div class="explanation-box" style="background: #f0f8ff; border-color: #4facfe;">
                        <strong>⚡ Real-World Use Case:</strong> Ideal when you need the result of async work:
                        <ul style="margin: 5px 0 0 20px; font-size: 0.9em;">
                            <li>Parallel API calls - fetch multiple data sources simultaneously</li>
                            <li>Concurrent computations - process multiple calculations at once</li>
                            <li>Parallel file processing - read/parse multiple files concurrently</li>
                            <li>Combined operations - wait for multiple async tasks to complete</li>
                        </ul>
                    </div>
                    <div class="code-snippet">
                        <span class="code-keyword">val</span> deferred = <span class="code-keyword">async</span> {
                            <span class="code-comment">// This runs asynchronously</span>
                            <span class="code-function">delay</span>(<span class="code-string">2000</span>)
                            <span class="code-keyword">return@async</span> <span class="code-string">"Result!"</span>
                        }
                        
                        <span class="code-comment">// Do other work...</span>
                        <span class="code-function">println</span>(<span class="code-string">"Doing other work"</span>)
                        
                        <span class="code-comment">// Get result when needed</span>
                        <span class="code-keyword">val</span> result = deferred.<span class="code-function">await</span>()
                        <span class="code-function">println</span>(<span class="code-string">"Got: $result"</span>)
                    </div>
                    <div class="visualization-area">
                        <div class="visualization-header">Async Execution</div>
                        <div class="visualization-content" id="async-viz">
                            <div style="display: flex; justify-content: space-around; align-items: center; padding: 40px;">
                                <div id="async-deferred" style="text-align: center;">
                                    <div class="coroutine-visual">Deferred</div>
                                    <small>Created immediately</small>
                                </div>
                                <div style="font-size: 2em;">→</div>
                                <div id="async-result" style="text-align: center;">
                                    <div style="padding: 10px 20px; background: #f0f0f0; border-radius: 6px; color: #666;">
                                        Awaiting...
                                    </div>
                                    <small>Result after await()</small>
                                </div>
                            </div>
                            <div class="timeline">
                                <div class="progress-bar" id="async-progress"></div>
                            </div>
                        </div>
                    </div>
                    <button class="btn btn-primary" onclick="animateAsync()">
                        ▶️ Start Async
                    </button>
                </div>

                <!-- runBlocking -->
                <div class="coroutine-card">
                    <div class="card-header">
                        <h3 class="card-title">runBlocking</h3>
                        <span class="status-badge status-idle" id="blocking-status">Idle</span>
                    </div>
                    <p class="description">
                        <strong>Blocks the current thread</strong> until the coroutine completes.
                        Used in main() functions and tests. Avoid in production code!
                    </p>
                    <div class="explanation-box" style="background: #ecf0f1; border-color: #34495e;">
                        <strong>⚠️ Real-World Use Case:</strong> Limited use cases - be careful!:
                        <ul style="margin: 5px 0 0 20px; font-size: 0.9em;">
                            <li>Main function - bridging between blocking and suspending worlds</li>
                            <li>Unit tests - testing suspend functions in blocking test frameworks</li>
                            <li>Integration tests - waiting for async operations to complete</li>
                            <li>Script/utility functions - simple command-line tools</li>
                        </ul>
                        <div style="margin-top: 8px; color: #e74c3c; font-weight: 500;">
                            ❌ Avoid in Android UI code - blocks the Main thread!
                        </div>
                    </div>
                    <div class="code-snippet">
                        <span class="code-keyword">fun</span> <span class="code-function">main</span>() = <span class="code-keyword">runBlocking</span> {
                            <span class="code-comment">// This blocks the main thread</span>
                            <span class="code-function">println</span>(<span class="code-string">"Start"</span>)
                            <span class="code-function">delay</span>(<span class="code-string">2000</span>)
                            <span class="code-function">println</span>(<span class="code-string">"End"</span>)
                        }
                        
                        <span class="code-comment">// Nothing runs until runBlocking completes!</span>
                    </div>
                    <div class="visualization-area">
                        <div class="visualization-header">Thread Blocking</div>
                        <div class="visualization-content" id="blocking-viz">
                            <div style="text-align: center; padding: 40px;">
                                <div id="blocking-thread" style="display: inline-block; padding: 20px 40px; background: #f0f0f0; border-radius: 8px; font-weight: 500;">
                                    Main Thread
                                </div>
                                <div id="blocking-indicator" style="margin-top: 20px; color: #dc3545; font-weight: bold;">
                                    <!-- Blocking indicator -->
                                </div>
                            </div>
                            <div class="timeline">
                                <div class="progress-bar" id="blocking-progress"></div>
                            </div>
                        </div>
                    </div>
                    <button class="btn btn-primary" onclick="animateBlocking()">
                        ▶️ Start RunBlocking
                    </button>
                </div>
            </div>

            <!-- Log Panel -->
            <div class="log-panel">
                <h3>
                    📋 Execution Log
                    <button class="btn btn-secondary clear-log-btn" onclick="clearLogs()">Clear</button>
                </h3>
                <div id="log-container">
                    <div class="log-entry" style="color: #666; font-style: italic;">
                        Click any animation to see detailed logs here...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Floating Support/Donation Section -->
    <div class="donation-floating">
        <div class="donation-text">☕ Support this project</div>
        <div class="kofi-button-container">
            <a href='https://ko-fi.com/zekiguler' target='_blank'>
                <img height='28' style='border:0px;height:28px;' src='https://storage.ko-fi.com/cdn/kofi6.png?v=6' border='0' alt='Buy Me a Coffee at ko-fi.com' />
            </a>
        </div>
    </div>

    <script>
        let logCounter = 0;
        let animationStates = {};

        function getTimestamp() {
            const now = new Date();
            return now.toTimeString().split(' ')[0] + '.' + now.getMilliseconds().toString().padStart(3, '0');
        }

        function addLog(message, type = 'info') {
            const logContainer = document.getElementById('log-container');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.innerHTML = `<span class="log-time">${getTimestamp()}</span>${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function clearLogs() {
            document.getElementById('log-container').innerHTML = '<div class="log-entry" style="color: #666; font-style: italic;">Logs cleared. Start an animation to see new logs...</div>';
        }

        function updateStatus(elementId, status) {
            const element = document.getElementById(elementId);
            element.className = `status-badge status-${status}`;
            element.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        }

        // Cold Flow Animation
        function animateColdFlow() {
            const collectors = document.getElementById('cold-flow-collectors');
            collectors.innerHTML = '';
            
            updateStatus('cold-flow-status', 'running');
            addLog('<strong>[Cold Flow]</strong> Starting cold flow animation', 'cold-flow');
            addLog('❄️ COLD FLOW: Each collector gets its OWN fresh execution', 'cold-flow');
            addLog('Cold Flow created with flow { emit(1); delay(1000); emit(2); delay(1000); emit(3) }', 'cold-flow');
            
            // Collector 1
            setTimeout(() => {
                addLog('<span class="highlight">Collector 1</span> subscribes to cold flow', 'cold-flow');
                addLog('Flow block executes from the beginning for Collector 1', 'cold-flow');
                
                const collector1 = document.createElement('div');
                collector1.className = 'collector-row active';
                collector1.innerHTML = `
                    <div class="collector-label">Collector 1</div>
                    <div class="emission-track" id="collector1-track"></div>
                `;
                collectors.appendChild(collector1);
                
                // Emit values for collector 1
                [1, 2, 3].forEach((value, index) => {
                    setTimeout(() => {
                        addLog(`Collector 1: emit(${value})`, 'cold-flow');
                        const emission = document.createElement('div');
                        emission.className = 'emission emission-cold';
                        emission.textContent = value;
                        emission.style.left = `${index * 120}px`;
                        document.getElementById('collector1-track').appendChild(emission);
                        
                        setTimeout(() => {
                            emission.style.transform = `translateX(${400}px)`;
                            emission.style.opacity = '0';
                        }, 500);
                    }, index * 1500);
                });
            }, 500);
            
            // Collector 2
            setTimeout(() => {
                addLog('<span class="highlight">Collector 2</span> subscribes to cold flow', 'cold-flow');
                addLog('🔄 INDEPENDENT EXECUTION: Flow block runs AGAIN from start!', 'cold-flow');
                addLog('⭐ KEY INSIGHT: Cold = Fresh execution per collector (like restarting a video)', 'cold-flow');
                
                const collector2 = document.createElement('div');
                collector2.className = 'collector-row active';
                collector2.innerHTML = `
                    <div class="collector-label">Collector 2</div>
                    <div class="emission-track" id="collector2-track"></div>
                `;
                collectors.appendChild(collector2);
                
                // Emit values for collector 2
                [1, 2, 3].forEach((value, index) => {
                    setTimeout(() => {
                        addLog(`Collector 2: emit(${value})`, 'cold-flow');
                        const emission = document.createElement('div');
                        emission.className = 'emission emission-cold';
                        emission.textContent = value;
                        emission.style.left = `${index * 120}px`;
                        document.getElementById('collector2-track').appendChild(emission);
                        
                        setTimeout(() => {
                            emission.style.transform = `translateX(${400}px)`;
                            emission.style.opacity = '0';
                        }, 500);
                    }, index * 1500);
                });
            }, 3000);
            
            // Complete
            setTimeout(() => {
                updateStatus('cold-flow-status', 'completed');
                addLog('<strong>[Cold Flow]</strong> Animation completed', 'cold-flow');
                addLog('Key takeaway: Each collector triggered its own flow execution', 'cold-flow');
                addLog('💡 Example: getUserPosts().collect { } - each screen gets fresh data', 'cold-flow');
            }, 8000);
        }

        // SharedFlow Animation
        function animateSharedFlow() {
            const collectors = document.getElementById('shared-flow-collectors');
            const bufferSlots = document.querySelectorAll('#shared-buffer .buffer-slot');
            collectors.innerHTML = '';
            let replayBuffer = [];
            
            updateStatus('shared-flow-status', 'running');
            addLog('<strong>[SharedFlow]</strong> Starting SharedFlow animation', 'shared-flow');
            addLog('🔥 HOT FLOW: ONE source broadcasts to ALL collectors', 'shared-flow');
            addLog('SharedFlow created with replay = 2 (keeps last 2 values)', 'shared-flow');
            
            // Start emitting
            addLog('Producer starts emitting values...', 'shared-flow');
            
            // Collector 1 joins immediately
            const collector1 = document.createElement('div');
            collector1.className = 'collector-row';
            collector1.innerHTML = `
                <div class="collector-label">Collector 1</div>
                <div class="emission-track" id="shared-collector1-track"></div>
            `;
            collectors.appendChild(collector1);
            
            setTimeout(() => {
                collector1.classList.add('active');
                addLog('<span class="highlight">Collector 1</span> subscribes (gets all values)', 'shared-flow');
            }, 100);
            
            // Emit values
            [1, 2, 3, 4, 5].forEach((value, index) => {
                setTimeout(() => {
                    addLog(`📡 Broadcasting: emit(${value})`, 'shared-flow');
                    
                    // Update replay buffer
                    replayBuffer.push(value);
                    if (replayBuffer.length > 2) {
                        replayBuffer.shift();
                    }
                    
                    // Update buffer visualization
                    bufferSlots.forEach((slot, i) => {
                        if (i < replayBuffer.length) {
                            slot.textContent = replayBuffer[i];
                            slot.classList.add('filled');
                        } else {
                            slot.textContent = '-';
                            slot.classList.remove('filled');
                        }
                    });
                    
                    // Show emission to active collectors (only in SharedFlow container)
                    const sharedContainer = document.getElementById('shared-flow-collectors');
                    const tracks = sharedContainer.querySelectorAll('.collector-row.active .emission-track');
                    tracks.forEach(track => {
                        const emission = document.createElement('div');
                        emission.className = 'emission emission-shared';
                        emission.textContent = value;
                        emission.style.left = '0px';
                        track.appendChild(emission);
                        
                        setTimeout(() => {
                            emission.style.transform = `translateX(${400}px)`;
                            emission.style.opacity = '0';
                        }, 100);
                    });
                    
                    // Collector 2 joins after value 3
                    if (value === 3) {
                        setTimeout(() => {
                            const collector2 = document.createElement('div');
                            collector2.className = 'collector-row active';
                            collector2.innerHTML = `
                                <div class="collector-label">Collector 2</div>
                                <div class="emission-track" id="shared-collector2-track"></div>
                            `;
                            collectors.appendChild(collector2);
                            
                            addLog('<span class="highlight">Collector 2</span> subscribes late!', 'shared-flow');
                            addLog(`🎯 SHARED BENEFIT: Gets replay buffer: [${replayBuffer.join(', ')}] + future values`, 'shared-flow');
                            addLog('⭐ KEY INSIGHT: Hot = Join ongoing broadcast (like live TV)', 'shared-flow');
                            
                            // Show replay values
                            replayBuffer.forEach((replayValue, i) => {
                                setTimeout(() => {
                                    const emission = document.createElement('div');
                                    emission.className = 'emission emission-shared';
                                    emission.textContent = replayValue;
                                    emission.style.left = '0px';
                                    emission.style.opacity = '0.7';
                                    document.getElementById('shared-collector2-track').appendChild(emission);
                                    
                                    setTimeout(() => {
                                        emission.style.transform = `translateX(${400}px)`;
                                        emission.style.opacity = '0';
                                    }, 100);
                                }, i * 300);
                            });
                        }, 500);
                    }
                }, index * 1500);
            });
            
            // Complete
            setTimeout(() => {
                updateStatus('shared-flow-status', 'completed');
                addLog('<strong>[SharedFlow]</strong> Animation completed', 'shared-flow');
                addLog('Key takeaway: SharedFlow broadcasts to all active collectors', 'shared-flow');
                addLog('💡 Example: userLoginEvents.emit(user) - all screens get notified', 'shared-flow');
            }, 9000);
        }

        // StateFlow Animation
        function animateStateFlow() {
            const stateDisplay = document.getElementById('current-state');
            const timeline = document.getElementById('state-updates-timeline');
            timeline.innerHTML = '';
            
            updateStatus('state-flow-status', 'running');
            addLog('<strong>[StateFlow]</strong> Starting StateFlow animation', 'state-flow');
            addLog('🎯 STATE HOLDER: Always has ONE current value', 'state-flow');
            addLog('StateFlow created with initial value: 0', 'state-flow');
            addLog('🔄 Auto-skips duplicates + new collectors get current state immediately', 'state-flow');
            
            const updates = [
                { value: 1, skip: false },
                { value: 2, skip: false },
                { value: 2, skip: true },
                { value: 3, skip: false },
                { value: 3, skip: true },
                { value: 3, skip: true },
                { value: 4, skip: false }
            ];
            
            updates.forEach((update, index) => {
                setTimeout(() => {
                    if (update.skip) {
                        addLog(`❌ Trying to set value: ${update.value} - <span class="highlight">SKIPPED</span> (duplicate)`, 'state-flow');
                        
                        const skipEl = document.createElement('div');
                        skipEl.style.display = 'inline-block';
                        skipEl.style.margin = '5px';
                        skipEl.style.padding = '10px';
                        skipEl.style.background = '#ffebee';
                        skipEl.style.color = '#c62828';
                        skipEl.style.borderRadius = '6px';
                        skipEl.style.textDecoration = 'line-through';
                        skipEl.textContent = update.value;
                        timeline.appendChild(skipEl);
                    } else {
                        addLog(`✅ State updated: ${update.value}`, 'state-flow');
                        stateDisplay.textContent = `Current State: ${update.value}`;
                        
                        const updateEl = document.createElement('div');
                        updateEl.style.display = 'inline-block';
                        updateEl.style.margin = '5px';
                        updateEl.style.padding = '10px';
                        updateEl.style.background = '#e8f5e9';
                        updateEl.style.color = '#2e7d32';
                        updateEl.style.borderRadius = '6px';
                        updateEl.style.fontWeight = 'bold';
                        updateEl.textContent = update.value;
                        timeline.appendChild(updateEl);
                    }
                }, index * 800);
            });
            
            setTimeout(() => {
                addLog('New collector subscribes...', 'state-flow');
                addLog('✅ INSTANT VALUE: Gets current state (4) immediately!', 'state-flow');
                addLog('⭐ WHEN TO USE StateFlow: UI state, settings, authentication status', 'state-flow');
                addLog('⭐ WHEN TO USE SharedFlow: Events, notifications, live updates', 'state-flow');
                updateStatus('state-flow-status', 'completed');
                addLog('<strong>[StateFlow]</strong> Animation completed', 'state-flow');
                addLog('💡 Example: themeState.value = DarkMode - all UI components update', 'state-flow');
            }, 6000);
        }

        // Channel state
        let channelMode = 'rendezvous'; // 'rendezvous' or 'buffered'
        
        function switchChannelMode(mode) {
            channelMode = mode;
            const rendezvousBtn = document.getElementById('rendezvous-btn');
            const bufferedBtn = document.getElementById('buffered-btn');
            const modeDisplay = document.getElementById('channel-mode-display');
            
            // Update button styles
            rendezvousBtn.className = mode === 'rendezvous' ? 'btn btn-primary' : 'btn btn-secondary';
            bufferedBtn.className = mode === 'buffered' ? 'btn btn-primary' : 'btn btn-secondary';
            
            // Update mode display
            if (mode === 'rendezvous') {
                modeDisplay.textContent = 'Mode: Rendezvous (capacity = 0) - Direct handoff';
                modeDisplay.style.color = '#e74c3c';
            } else {
                modeDisplay.textContent = 'Mode: Buffered (capacity = 3) - Queue with buffer';
                modeDisplay.style.color = '#2ecc71';
            }
            
            addLog(`🔄 Switched to ${mode === 'rendezvous' ? 'Rendezvous' : 'Buffered'} channel mode`, 'channel');
        }

        // Channel Animation
        function animateChannel() {
            const queueEl = document.getElementById('channel-queue');
            const producerEl = document.getElementById('channel-producer');
            const consumerEl = document.getElementById('channel-consumer');
            const rendezvousIndicator = document.getElementById('rendezvous-indicator');
            
            queueEl.innerHTML = '';
            producerEl.innerHTML = '';
            consumerEl.innerHTML = '';
            rendezvousIndicator.innerHTML = '';
            
            updateStatus('channel-status', 'running');
            addLog('<strong>[Channel]</strong> Starting Channel animation', 'channel');
            
            if (channelMode === 'rendezvous') {
                addLog('🤝 RENDEZVOUS CHANNEL: Direct handoff, sender waits for receiver', 'channel');
                addLog('📬 Capacity = 0: No buffering, synchronous communication', 'channel');
                animateRendezvousChannel();
            } else {
                addLog('📦 BUFFERED CHANNEL: Queue with buffer space', 'channel');
                addLog('📬 Capacity = 3: Sender can send without waiting if buffer has space', 'channel');
                animateBufferedChannel();
            }
            
            addLog('🔄 vs Flow: Channel = queue (consume once), Flow = broadcast (all get)', 'channel');
        }
        
        function animateRendezvousChannel() {
            const queueEl = document.getElementById('channel-queue');
            const producerEl = document.getElementById('channel-producer');
            const consumerEl = document.getElementById('channel-consumer');
            const rendezvousIndicator = document.getElementById('rendezvous-indicator');
            
            // Show "No Queue" indicator for rendezvous
            queueEl.innerHTML = '<div style="padding: 20px; text-align: center; color: #666; font-style: italic;">No Buffer (Direct Handoff)</div>';
            
            let valueIndex = 1;
            
            function sendReceiveStep() {
                if (valueIndex > 5) {
                    setTimeout(() => {
                        updateStatus('channel-status', 'completed');
                        addLog('<strong>[Channel]</strong> Rendezvous animation completed', 'channel');
                        addLog('⭐ KEY INSIGHT: Rendezvous = Synchronous handoff, perfect for coordination', 'channel');
                    }, 1000);
                    return;
                }
                
                // Producer wants to send
                addLog(`Producer: Trying to send(${valueIndex})...`, 'channel');
                rendezvousIndicator.innerHTML = `🤝 Waiting for handoff of value ${valueIndex}`;
                
                const sendEl = document.createElement('div');
                sendEl.className = 'coroutine-visual';
                sendEl.style.background = 'linear-gradient(135deg, #f39c12 0%, #e67e22 100%)';
                sendEl.textContent = `Waiting to Send(${valueIndex})`;
                producerEl.appendChild(sendEl);
                
                // Producer waits...
                setTimeout(() => {
                    addLog(`🔄 Producer SUSPENDED: Waiting for receiver...`, 'channel');
                    sendEl.style.opacity = '0.6';
                    sendEl.textContent = `⏳ Suspended Send(${valueIndex})`;
                    
                    // Consumer becomes ready
                    setTimeout(() => {
                        addLog(`Consumer: Ready to receive!`, 'channel');
                        
                        const receiveEl = document.createElement('div');
                        receiveEl.className = 'coroutine-visual';
                        receiveEl.style.background = 'linear-gradient(135deg, #2ecc71 0%, #27ae60 100%)';
                        receiveEl.textContent = `Ready to Receive`;
                        consumerEl.appendChild(receiveEl);
                        
                        // Direct handoff happens
                        setTimeout(() => {
                            addLog(`✅ DIRECT HANDOFF: ${valueIndex} transferred instantly!`, 'channel');
                            rendezvousIndicator.innerHTML = `⚡ Direct transfer of ${valueIndex} completed`;
                            
                            sendEl.style.background = 'linear-gradient(135deg, #2ecc71 0%, #27ae60 100%)';
                            sendEl.textContent = `✅ Sent(${valueIndex})`;
                            receiveEl.textContent = `✅ Received(${valueIndex})`;
                            
                            setTimeout(() => {
                                sendEl.style.opacity = '0.3';
                                receiveEl.style.opacity = '0.3';
                                rendezvousIndicator.innerHTML = '';
                                valueIndex++;
                                setTimeout(sendReceiveStep, 500);
                            }, 1000);
                        }, 800);
                    }, 1500);
                }, 1000);
            }
            
            sendReceiveStep();
        }
        
        function animateBufferedChannel() {
            const queueEl = document.getElementById('channel-queue');
            const producerEl = document.getElementById('channel-producer');
            const consumerEl = document.getElementById('channel-consumer');
            const rendezvousIndicator = document.getElementById('rendezvous-indicator');
            
            let queueItems = [];
            const maxCapacity = 3;
            
            // Producer
            addLog('Producer starts sending to buffered channel...', 'channel');
            [1, 2, 3, 4, 5].forEach((value, index) => {
                setTimeout(() => {
                    if (queueItems.length < maxCapacity) {
                        addLog(`Producer: channel.send(${value}) ✅ Added to buffer`, 'channel');
                        queueItems.push(value);
                        
                        const sendEl = document.createElement('div');
                        sendEl.className = 'coroutine-visual';
                        sendEl.style.background = 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)';
                        sendEl.textContent = `Send(${value})`;
                        producerEl.appendChild(sendEl);
                        
                        // Add to queue
                        const queueItem = document.createElement('div');
                        queueItem.className = 'queue-item';
                        queueItem.textContent = value;
                        queueItem.id = `queue-item-${value}`;
                        queueEl.appendChild(queueItem);
                        
                        rendezvousIndicator.innerHTML = `Buffer: ${queueItems.length}/${maxCapacity}`;
                        
                        setTimeout(() => sendEl.style.opacity = '0.3', 1000);
                    } else {
                        addLog(`Producer: channel.send(${value}) ⏳ SUSPENDED (buffer full)`, 'channel');
                        rendezvousIndicator.innerHTML = `⏳ Producer waiting - buffer full (${queueItems.length}/${maxCapacity})`;
                    }
                    
                    // Consumer receives after delay
                    setTimeout(() => {
                        if (queueItems.length > 0) {
                            const received = queueItems.shift();
                            addLog(`Consumer: channel.receive() -> ${received} ✅ CONSUMED (removed from buffer)`, 'channel');
                            
                            const receiveEl = document.createElement('div');
                            receiveEl.className = 'coroutine-visual';
                            receiveEl.style.background = 'linear-gradient(135deg, #2ecc71 0%, #27ae60 100%)';
                            receiveEl.textContent = `Received(${received})`;
                            consumerEl.appendChild(receiveEl);
                            
                            // Remove from queue
                            const itemEl = document.getElementById(`queue-item-${received}`);
                            if (itemEl) {
                                itemEl.style.transform = 'scale(0)';
                                setTimeout(() => itemEl.remove(), 300);
                            }
                            
                            rendezvousIndicator.innerHTML = `Buffer: ${queueItems.length}/${maxCapacity}`;
                            setTimeout(() => receiveEl.style.opacity = '0.3', 1000);
                        }
                    }, 800 + (index * 200));
                }, index * 1200);
            });
            
            setTimeout(() => {
                updateStatus('channel-status', 'completed');
                addLog('<strong>[Channel]</strong> Buffered animation completed', 'channel');
                addLog('⭐ KEY INSIGHT: Buffered = Asynchronous with queue, good for decoupling', 'channel');
                addLog('💡 Example: taskQueue.send(downloadTask) - workers process one task each', 'channel');
            }, 7000);
        }

        // Context Animation
        function animateContext() {
            const threads = ['main-thread', 'io-thread', 'default-thread'];
            const threadNames = ['Main', 'IO', 'Default'];
            const coroutineEl = document.getElementById('context-coroutine');
            
            updateStatus('context-status', 'running');
            addLog('<strong>[withContext]</strong> Starting context switching animation', 'context');
            addLog('🧵 THREAD OPTIMIZATION: Right work on right thread = better performance', 'context');
            
            // Reset threads
            threads.forEach(id => document.getElementById(id).classList.remove('active'));
            
            const sequence = [
                { thread: 0, message: '🖱️ Main thread: UI setup (keep UI responsive)', task: 'UI Setup' },
                { thread: 1, message: '🌐 withContext(IO): Network call (don\'t block UI)', task: 'Network Request' },
                { thread: 1, message: '📡 IO thread: Network operation in progress...', task: 'Loading...' },
                { thread: 2, message: '⚡ withContext(Default): Heavy computation', task: 'Process Data' },
                { thread: 0, message: '🖱️ withContext(Main): UI update (back to Main)', task: 'Update UI' }
            ];
            
            sequence.forEach((step, index) => {
                setTimeout(() => {
                    // Clear active threads
                    threads.forEach(id => document.getElementById(id).classList.remove('active'));
                    
                    // Activate current thread
                    document.getElementById(threads[step.thread]).classList.add('active');
                    
                    // Update coroutine visualization
                    coroutineEl.innerHTML = `
                        <div class="coroutine-visual">
                            ${step.task}
                        </div>
                        <small style="color: #666; margin-top: 5px; display: block;">
                            on ${threadNames[step.thread]} thread
                        </small>
                    `;
                    
                    addLog(`${step.message}`, 'context');
                    
                    if (index === sequence.length - 1) {
                        setTimeout(() => {
                            updateStatus('context-status', 'completed');
                            addLog('<strong>[withContext]</strong> Animation completed', 'context');
                            addLog('⭐ PERFORMANCE WIN: UI stays responsive, work happens on optimal threads', 'context');
                            addLog('💡 Rule: IO for network/files, Default for CPU work, Main for UI', 'context');
                        }, 1000);
                    }
                }, index * 1500);
            });
        }

        // Launch Animation
        function animateLaunch() {
            const viz = document.getElementById('launch-coroutine');
            const progress = document.getElementById('launch-progress');
            
            updateStatus('launch-status', 'running');
            addLog('<strong>[launch]</strong> Starting launch coroutine', 'launch');
            addLog('launch { } creates a new coroutine', 'launch');
            addLog('Returns Job immediately (fire-and-forget)', 'launch');
            
            viz.innerHTML = '<div class="coroutine-visual">Coroutine Running...</div>';
            
            let progressValue = 0;
            const interval = setInterval(() => {
                progressValue += 5;
                progress.style.width = progressValue + '%';
                
                if (progressValue === 50) {
                    addLog('Coroutine: delay(2000) - suspending...', 'launch');
                    viz.innerHTML = '<div class="coroutine-visual" style="opacity: 0.6;">Coroutine Suspended</div>';
                }
                
                if (progressValue >= 100) {
                    clearInterval(interval);
                    viz.innerHTML = '<div class="coroutine-visual" style="background: #2ecc71;">Coroutine Completed!</div>';
                    updateStatus('launch-status', 'completed');
                    addLog('Coroutine completed successfully', 'launch');
                    addLog('<strong>[launch]</strong> Animation completed', 'launch');
                }
            }, 40);
        }

        // Async Animation
        function animateAsync() {
            const deferredEl = document.getElementById('async-deferred');
            const resultEl = document.getElementById('async-result');
            const progress = document.getElementById('async-progress');
            
            updateStatus('async-status', 'running');
            addLog('<strong>[async]</strong> Starting async coroutine', 'async');
            addLog('async { } creates a coroutine that returns Deferred<T>', 'async');
            addLog('Deferred created immediately (doesn\'t block)', 'async');
            
            resultEl.innerHTML = `
                <div style="padding: 10px 20px; background: #fff3cd; border-radius: 6px; color: #856404;">
                    Awaiting...
                </div>
                <small>Computation in progress</small>
            `;
            
            let progressValue = 0;
            const interval = setInterval(() => {
                progressValue += 4;
                progress.style.width = progressValue + '%';
                
                if (progressValue === 50) {
                    addLog('Async coroutine: performing computation...', 'async');
                }
                
                if (progressValue >= 100) {
                    clearInterval(interval);
                    addLog('Calling deferred.await() to get result', 'async');
                    addLog('Got result: "Result!"', 'async');
                    
                    resultEl.innerHTML = `
                        <div style="padding: 10px 20px; background: #d4edda; border-radius: 6px; color: #155724; font-weight: bold;">
                            "Result!"
                        </div>
                        <small>Result received</small>
                    `;
                    
                    updateStatus('async-status', 'completed');
                    addLog('<strong>[async]</strong> Animation completed', 'async');
                }
            }, 50);
        }

        // RunBlocking Animation
        function animateBlocking() {
            const threadEl = document.getElementById('blocking-thread');
            const indicatorEl = document.getElementById('blocking-indicator');
            const progress = document.getElementById('blocking-progress');
            
            updateStatus('blocking-status', 'suspended');
            addLog('<strong>[runBlocking]</strong> Starting runBlocking', 'blocking');
            addLog('⚠️ WARNING: runBlocking BLOCKS the current thread!', 'blocking');
            
            threadEl.style.background = '#ffebee';
            threadEl.style.color = '#c62828';
            threadEl.textContent = 'Main Thread (BLOCKED!)';
            indicatorEl.textContent = '🛑 Thread is blocked - nothing else can run!';
            
            let progressValue = 0;
            const interval = setInterval(() => {
                progressValue += 3;
                progress.style.width = progressValue + '%';
                
                if (progressValue === 50) {
                    addLog('Inside runBlocking: delay(2000) - still blocking thread...', 'blocking');
                }
                
                if (progressValue >= 100) {
                    clearInterval(interval);
                    threadEl.style.background = '#d4edda';
                    threadEl.style.color = '#155724';
                    threadEl.textContent = 'Main Thread (Released)';
                    indicatorEl.textContent = '✅ Thread unblocked - can continue';
                    indicatorEl.style.color = '#28a745';
                    
                    updateStatus('blocking-status', 'completed');
                    addLog('runBlocking completed - thread released', 'blocking');
                    addLog('<strong>[runBlocking]</strong> Use only in main() or tests!', 'blocking');
                }
            }, 60);
        }

        function startAllAnimations() {
            addLog('<strong>🚀 Starting comprehensive coroutine demonstration...</strong>', 'info');
            addLog('📚 LEARNING GOALS:', 'info');
            addLog('   • Cold vs Hot: Independent execution vs Broadcasting', 'info');
            addLog('   • StateFlow vs SharedFlow: State holder vs Event emitter', 'info');
            addLog('   • Channel vs Flow: Queue consumption vs Broadcasting', 'info');
            addLog('   • withContext: Performance through proper thread usage', 'info');
            
            setTimeout(() => animateLaunch(), 0);
            setTimeout(() => animateAsync(), 500);
            setTimeout(() => animateColdFlow(), 1000);
            setTimeout(() => animateSharedFlow(), 1500);
            setTimeout(() => animateStateFlow(), 2000);
            setTimeout(() => animateChannel(), 2500);
            setTimeout(() => animateContext(), 3000);
            setTimeout(() => animateBlocking(), 3500);
        }

        function resetAllAnimations() {
            // Clear all visualizations
            document.getElementById('cold-flow-collectors').innerHTML = '';
            document.getElementById('shared-flow-collectors').innerHTML = '';
            document.getElementById('state-updates-timeline').innerHTML = '';
            document.getElementById('channel-queue').innerHTML = '';
            document.getElementById('channel-producer').innerHTML = '';
            document.getElementById('channel-consumer').innerHTML = '';
            document.getElementById('context-coroutine').innerHTML = '';
            document.getElementById('launch-coroutine').innerHTML = '';
            
            // Reset progress bars
            document.querySelectorAll('.progress-bar').forEach(bar => bar.style.width = '0%');
            
            // Reset statuses
            const statuses = ['launch', 'async', 'cold-flow', 'shared-flow', 'state-flow', 'channel', 'context', 'blocking'];
            statuses.forEach(status => updateStatus(`${status}-status`, 'idle'));
            
            // Reset specific elements
            document.getElementById('current-state').textContent = 'Current State: 0';
            document.getElementById('async-result').innerHTML = `
                <div style="padding: 10px 20px; background: #f0f0f0; border-radius: 6px; color: #666;">
                    Awaiting...
                </div>
                <small>Result after await()</small>
            `;
            document.getElementById('blocking-thread').style.background = '#f0f0f0';
            document.getElementById('blocking-thread').style.color = '#333';
            document.getElementById('blocking-thread').textContent = 'Main Thread';
            document.getElementById('blocking-indicator').textContent = '';
            
            // Reset threads
            document.querySelectorAll('.thread').forEach(thread => thread.classList.remove('active'));
            
            // Reset buffer
            document.querySelectorAll('#shared-buffer .buffer-slot').forEach(slot => {
                slot.textContent = '-';
                slot.classList.remove('filled');
            });
            
            addLog('<strong>All animations reset</strong>', 'info');
        }
    </script>
</body>
</html>